---
title: 小程序直播相关
date: 2020-06-15 17:57:45
tags: 微信小程序
categories: 微信小程序
---

### 直播插件
因为小程序组件`<live-player />`需要直播相关主体，所以用了腾讯云直播插件`<live-room-play />`
[相关文档](https://cloud.tencent.com/document/product/1078/42916)
其中有个播放状态监控：
```html
<!-- 这里有个小窗播放`picture-in-picture-mode`此插件目前还不支持(version:1.2.2)，所以只能自己写一个小窗，期待中... -->
<live-room-play class="live-room" objectFit="contain" version="2" picture-in-picture-mode="['push', 'pop']" liveAppID="" autoplay="{{autoPlay}}" bindPlayEvent="playStatus" bindNetStatus="netStatus" autopause="true" bindError="error" playUrl="{{playUrl}}">
```
```js
//播放状态变化事件回调
playStatus(e) {
  let that = this;
  console.log("播放状态", e.detail)
  if (e.detail.code == 2004) {
    //视频播放开始
    this.setData({
      livePause: false
    })
    if (this.timer) {
      clearInterval(this.timer)
    }
  }
  if (e.detail.code == 2103) {
    //网络断连, 启动自动重连
  }
  if (e.detail.code == -2301) {
    // -2301:网络断连且经多次重连抢救无效
    this.setData({
      autoPlay: false,
      livePause: true
    })
    //这里写了个定时器重复请求play直播流，如果直播连接成功清除定时器，应该有好方案，没想到
    this.timer = setInterval(() => {
      console.log("开始请求直播拉流")
      that.setData({
        playUrl: that.data.playUrl,
        autoPlay: true
      })
      that.liveRoomComponent.start();
    }, 5000)
  }
  if (e.detail.code == 2006) {
    //2006:视频播放结束;
    this.setData({
      liveEnd: true
    })
  }
},
```

### 即时通信IM
##### 因为是直播，所以IM类型选择直播群
[官方文档很详细](cloud.tencent.com/document/product/269/43002)

这里加几个注意的点：
##### 1. IM设置头像昵称要在ready之后调用
```js
tim.on(TIM.EVENT.SDK_READY, function (event) {
  // SDK ready 后接入侧才可以调用 sendMessage 等需要鉴权的接口，否则会提示失败！
  // event.name - TIM.EVENT.SDK_READY
  console.log("SDK ready", event)
  // 修改个人标配资料
  tim.updateMyProfile({
    nick: wx.getStorageSync('wxUserInfo').nickName,
    avatar: wx.getStorageSync('wxUserInfo').avatarUrl
  }).then(function (imResponse) {
    console.log(imResponse.data); // 更新资料成功
  }).catch(function (imError) {
    console.warn('updateMyProfile error:', imError); // 更新资料失败的相关信息
  });
})
```

##### 2.有成员加群回调只有调用登录`tim.login`方法 再调用加群`tim.joinGroup`方法 才会触发
示例：
```js
//登录IM
tim.login({
  userID: uid, //用户ID后台返回的用户ID
  userSig: data.data.UserSig //后台返回的根据用户ID生成的加密串
}).then(function (imResponse) {
  console.log("登录成功", imResponse.data); // 登录成功
  tim.joinGroup({
    groupID: that.data.groupID,  //群ID
    type: TIM.TYPES.GRP_AVCHATROOM //类型为直播群必填字段
  }).then(function (imResponse) {
    console.log("加群成功", imResponse)
    switch (imResponse.data.status) {
      case TIM.TYPES.JOIN_STATUS_SUCCESS: // 加群成功
        // console.log(imResponse.data.group) // 加入的群组资料
        break
      case TIM.TYPES.JOIN_STATUS_ALREADY_IN_GROUP: // 已经在群中
        break
      default:
        break
    }
  }).catch(function (imError) {
    console.warn('加群失败', imError) // 申请加群失败的相关信息
  });
  resolve(imResponse)
}).catch(function (imError) {
  console.warn('登录IM失败:', imError); // 登录失败的相关信息
  reject(imError)
});
```

##### 3.判断是否被禁言，调用发消息（包括各种类型的消息）前先判断是否被禁言，如果禁言调用发消息会报错（注意必须在SDK_READY之后调用）
示例：
```js
//判断是否被禁言
checkUserBanned() {
  let that = this;
  return new Promise((resolve, reject) => {
    tim.getGroupMemberProfile({
      groupID: that.data.groupID,
      userIDList: [wx.getStorageSync('userInfo').uid] //用户ID，必须为数组
    }).then(function (imResponse) {
      // console.log(imResponse.data.memberList); // 群成员列表
      resolve(imResponse.data.memberList)
    }).catch(function (imError) {
      // console.warn('getGroupMemberProfile error:', imError);
      reject(imError)
    });
  })
},
//检查是否被禁言
that.checkUserBanned().then((res) => {
  for (let groupMember of res) {
    if (groupMember.muteUntil * 1000 > Date.now()) {
      //禁言中
      wx.showToast({
        title: '您已被禁言',
        icon: "none"
      })
    } else {
      //未禁言
      let message = tim.createCustomMessage({
        to: that.data.groupID,
        conversationType: TIM.TYPES.CONV_GROUP,
        payload: {
          data: '', // 用于标识该消息是什么类型自定义消息
          description: that.liveId, // 直播ID
          extension: number + "" // 
        }
      });
      // 3. 发送消息
      let promise = tim.sendMessage(message);
      promise.then(function (imResponse) {
        // 发送成功
        console.log(imResponse);
      }).catch(function (imError) {
        // 发送失败
        console.warn('sendMessage error:', imError);
      });
    }
  }
})
```

##### 4.进场消息、购买消息等只显示一次，并且显示时间相同的消息实现
* 基本原理就是`onShow`生命周期触发一个定时器方法，在收到进群消息或购买消息回调之后，把收到的消息push到一个相同的数组中，然后页面只展示第一条数组，因为动画是三秒一条消息，所以定时器三秒轮询一次，第一条三秒之后删除，这样不会导致数组内存过大，
示例：
```js
onShow(){
  this.tipMsg()
},
buyMessage(message) {
  //收到购买消息回调之后，往tipsData数组push一条数据，定时器监测到有数据便会渲染出来
  let that = this;
  let res = {};
  res.avatar = message.avatar;
  res.nick = message.nick;
  res.type = 3;
  that.data.tipsData.push(res)
},
tipMsg() {
  let that = this;
  that.tipTimer = setInterval(() => {
    if (that.data.tipsData.length > 0) {
      that.setData({
        tipsDatas: that.data.tipsData[0] //这里的tipsData对象便是要渲染到页面中的单条数据
      })
      that.tipAnimation()
    }
  }, 3000);
},
tipAnimation() {
  let that = this;
  let animation = wx.createAnimation({
    duration: 300
  })
  animation.translateX(0).step()
  that.setData({
    animationData: animation.export()
  })
  setTimeout(() => {
    animation.translateX('-100%').step({
      duration: 0
    })
    that.setData({
      animationData: animation.export()
    })
    that.data.tipsData.shift()
    // console.log(that.data.tipsData)
  }, 2700);
},
```

tips：这样应该不是最优解，毕竟定时器触发还是有点耗性能的，loading...

这样做下来直播IM还是相对简单的，毕竟用的API还没有十分之一，很多API都是聊天群才用到的